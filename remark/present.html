<!DOCTYPE html>
<html>
<title>Contravariance in TypeScript</title>
<head>
    <meta charset="utf-8">
    <style>
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

        body {
            font-family: 'Droid Serif';
            color: white;

        }

        h1,
        h2,
        h3 {
            font-family: 'Arial';
            font-weight: normal;
            line-height: 100%;
            color: greenyellow;
        }

        /* h1, h2, h3 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; } */
        .remark-slide-content {
            font-size: 24px;
            line-height: 150%;
            background-color: black;
        }

        .remark-code,
        .remark-inline-code {
            font-family: 'Ubuntu Mono';
            background-color:darkslategrey;
        }

        a {
            color: lightblue;
        }

        img {
            border-radius: 6px;
            border: 1px solid #ddd;
        }
    </style>
</head>

<body>
    <textarea id="source">
class: center, middle

# Contraviance in TypeScript
## Bob Cook ( @typescriptbob )

???
This shows what is meant by contraviance and how TypeScript differs from some other languages in this area.
---

### TypeScript functions are contravarient
### with respect to their parameters

What does this mean ?

Let's break that down
---
### Types and sub types for basic types

Types and sub types are easy to think about for basic types

Each of the following resolves to true

(view in [TypeScript Playground](http://www.typescriptlang.org/play/?ssl=3&ssc=63&pln=1&pc=1#code/C4TwDgpgBAcgrgWwEYQE4FEAewIDsAmAzgIK4hQC8UuiKqUE2eRUAhmQPxTCpwQBcUAGasANoQgBuAFChIUAPJIAVhADGwLDgIkylKAHsV64AyY62erjz5RBI8VNnhoMCADc0W5oSWqN+rgeaGbaLEb+pta80PZiEpJAA)
 and hover over the type to evaluate it)

```typescript
type NumberExtendsAny = number extends any? true: false;
type ObjectExtendsAny = object extends any ? true : false;
type NeverExtendsObject = never extends object ? true : false;
```
---
### Types and sub types for objects

For objects, the subtype relationship is defined by the set of properties of the object.

Each of the following are true

```typescript
type XExtendsEmpty = { x: number } extends {} ? true: false;
type XYExtendsX = { x: number, y: number } extends {x: number} ? true : false;
```

You can think of this in terms of inheritance - a class that inherits from a base class is a subtype of the base. It can add more properties, but it cannot remove any.

---
### Types and sub types for functions
Functions also have subtypes and supertypes.

```typescript
function f1() { }
function f2(x: number) { }
function f3(x: number, y: number) { }
function f4() { return 42;}

// Each of the following are true

type f2ExtendsF1 = typeof f2 extends typeof f1? true: false;
type f3ExtendsF2 = typeof f3 extends typeof f2? true: false;
type f4ExtendsF1 = typeof f3 extends typeof f2? true: false;
```

---
and each of these type relationships are true

```typescript

function f1(x: any) { }
function f2(x: number) { }
function f3(x: {a: number, b: number}) { }
function f4(x: { a: number }) { }

type f2ExtendsF1 = typeof f2 extends typeof f1? true: false;
type f3ExtendsF1 = typeof f3 extends typeof f1? true: false;
type f4ExtendsF3 = typeof f4 extends typeof f3? true : false;
```
The last line could also be written as
```typescript
type FofXYExtendsFofX = typeof f3 extends typeof f2? true: false;
```
Note the inverse relationship to the *object* containing X and Y

---
Note how the following code is valid due to these relationships

```typescript
function apply(fn: typeof f3) {
    fn({a:42, b:64});
}
apply(f4);
```
You can see here that the Higher Order function expects a function of f3 type, but it accepts a function of f4 type because f4 is a subtype of f3

This is because the parameter of f4 is a supertype of the parameter of f3

Hence we say the function is contravariant to the type of it's parameters
---
### Classes and methods

When it comes to classes and method overrides this means you can do things in TypeScript you can't do 
in other languages like C++ or C#
---

Consider this TypeScript code
--
<img src="ts.png" width="97%" />

--

The BigPark class provides the implementation for the interfaces with 
a function which takes Vehicle as a parameter

This is perfectly valid TypeScript
---
Attempting the same construct in C# syntax will not compile
--
<img src="cs.png" width="97%" />
--
<img src="cs_error.png" width="97%" />

---
Neither will the C++ version
--
<img src="cpp.png" width="97%" />
--
<img src="cpp_error.png" width="97%" />
---
### Which is better?
--

A Car is a Vehicle, so a function which acts on a Vehicle may be a perfectly good implementation for a function which 
takes a Car as a parameter

--

In some ways this is a limitation in C++ and C#

--

What do you think?

</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"> </script>
    <script> var slideshow = remark.create(); </script>
</body>

</html>